<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RegressionTests</title>
    <style>
        p {font-family: sans-serif;}
        .ok {color: green;}
        .err {color: tomato;}
        .info {color: darkblue;}
    </style>
</head>
<body>
<div id="consoleDiv"></div>
<script type="module">
import {setValidationRules, setDefaultMandatoryMessagePrefix, getDefaultMandatoryMessagePrefix,
    setDefaultImmutableMessagePrefix, getDefaultImmutableMessagePrefix, setDefaultContentMessagePrefix,
    getDefaultContentMessagePrefix, setDefaultUpdateMessagePrefix, getDefaultUpdateMessagePrefix,
    getAllowedPropertyValues, isPropertyMandatory, isPropertyImmutable,
    validateMandatoryRules, validateMandatoryPropertyRules, validateImmutableRules, validateImmutablePropertyRules,
    validateContentRules, validateContentPropertyRules, validateUpdateRules, validateUpdatePropertyRules}
    from './CrossLanguageValidation_ES6.js';
import {sizeConstraintIsMet, rangeConstraintIsMet, dateConstraintIsMet, weekdayConstraintIsMet, equalsConstraintIsMet,
    equalsRefConstraintIsMet, regexConstraintIsMet, inflatePropertyIfMultiIndexed}
    from './CrossLanguageValidation_ES6.js';
import {testValidationRules, sometypeObject} from './RegressionTestsData_ES6.js';

const consoleDiv = document.getElementById("consoleDiv");

let okCount = 0, errorCount = 0;

function log(text, cssClass = "info") {
    const para = document.createElement("P");
    para.setAttribute("class", cssClass)
    para.appendChild(document.createTextNode(text));
    consoleDiv.appendChild(para);
}

function logResult() {
    const para = document.createElement("P");
    para.appendChild(document.createTextNode("Test summary: Runs: " + (okCount + errorCount) + ", Failures: " + errorCount));
    if (errorCount > 0) {
        para.setAttribute("class", 'err')
    } else {
        para.setAttribute("class", 'info')
    }
    consoleDiv.prepend(para);
}

function assert(msg, expected, compare) {
    if (Array.isArray(expected) && Array.isArray(compare)) {
        expected = expected.toString();
        compare = compare.toString();
    }
    if (expected !== compare) {
        log('Assertion failure: ' +  msg + ' - Expected "' + expected + '", but got "' + compare + '"', 'err');
        errorCount += 1;
    } else {
        log('Test o.k.: ' +  msg, 'ok');
        okCount += 1;
    }
}

setValidationRules(testValidationRules);

log(">>> Testing getAllowedPropertyValues");
assert('undefined allowed properties if no EQUALS_ANY* constraint exist',
    undefined, getAllowedPropertyValues("sometype", "number1", {"number1": 1}));
assert('allowed properties if EQUALS_ANY content constraint exist',
    ["one", "two"], getAllowedPropertyValues("sometype", "someString", {"notRelevant": 1}, ["aaa"]));
assert('allowed properties if EQUALS_ANY_REF content constraint exist',
    ["one", "two", "four", "six"], getAllowedPropertyValues("sometype", "someString",
        {"stringArray": ["one", "two"], "stringArray2": ["three", "four", "five", "six", "seven"]}, ["bbb"]));
assert('allowed properties if EQUALS_ANY update constraint exist',
    ["foo", "bar"], getAllowedPropertyValues("sometype", "someString", {"someString": "foo"}));


log(">>> Testing isPropertyMandatory");
assert('non-existing property is not mandatory',
    false, isPropertyMandatory("sometype", "non-existing", sometypeObject));
assert('customer is mandatory ',
    true, isPropertyMandatory("sometype", "customer", sometypeObject));
assert('customer.name is mandatory ',
    true, isPropertyMandatory("sometype", "customer.name", sometypeObject));
assert('number1 is mandatory for permission "aaa"',
    true, isPropertyMandatory("sometype", "number1", sometypeObject, ["aaa", "xxx"]));
assert('number1 is mandatory for permissions "bbb" and "aaa"',
    true, isPropertyMandatory("sometype", "number1", sometypeObject, ["xxx", "bbb", "aaa"]));
assert('number1 is mandatory for permission "ccc"',
    true, isPropertyMandatory("sometype", "number1", sometypeObject, ["ccc"]));
assert('number1 is mandatory for no (matching) permission',
    true, isPropertyMandatory("sometype", "number1", sometypeObject, ["xxx"]));
assert('array with *-index is mandatory',
    true, isPropertyMandatory("sometype", "stringArray[*]", sometypeObject));
assert('#distinct not allowed',
    false, isPropertyMandatory("sometype", "stringArray[*]#distinct", sometypeObject));
assert('#distinct not allowed',
    false, isPropertyMandatory("sometype", "stringArray[*]#distinct", sometypeObject));


log(">>> Testing validateMandatoryPropertyRules");
assert('number1 is mandatory and not null',
    [], validateMandatoryPropertyRules("sometype", "number1", {"number1": 1}));
assert('number1 is mandatory but null',
    ["error.validation.mandatory.sometype.number1"],
    validateMandatoryPropertyRules("sometype", "number1", {"number1": null}));
assert('stringArray[*] elements are not null',
    [], validateMandatoryPropertyRules("sometype", "stringArray[*]", sometypeObject));


log(">>> Testing validateMandatoryRules");
assert('Expecting empty error array',
    [], validateMandatoryRules("sometype", sometypeObject));
assert('Expecting array with 3 errors',
    ['error.validation.mandatory.sometype.customer#errcodesuffix',
        'error.validation.mandatory.sometype.customer.name',
        'error.validation.mandatory.sometype.number1'],
    validateMandatoryRules("sometype", {"customer": null, "number1": null}));


log(">>> Testing isPropertyImmutable");
assert('number1 is immutable for no (matching) permission',
    true, isPropertyImmutable("sometype", "number1", sometypeObject));
assert('#distinct not allowed',
    false, isPropertyImmutable("sometype", "stringArray[*]#distinct", sometypeObject));


log(">>> Testing validateImmutablePropertyRules");
assert('number1 is immutable and unchanged',
    [], validateImmutablePropertyRules("sometype", "number1", {"number1": 1}, {"number1": 1}));
assert('number1 is immutable but changed',
    ["error.validation.immutable.sometype.number1"],
    validateImmutablePropertyRules("sometype", "number1", {"number1": 1}, {"number1": 2}));


log(">>> Testing validateContentPropertyRules");
assert('nullValue EQUALS_NULL',
    [], validateContentPropertyRules("sometype", "nullValue", {"nullValue": null}));

assert('Number RANGE fits',
    [], validateContentPropertyRules("sometype", "number1", {"number1": 3}));
assert('Number RANGE min fails',
    ["error.validation.content.range.sometype.number1"],
    validateContentPropertyRules("sometype", "number1", {"number1": 0}));
assert('Number RANGE max fails',
    ["error.validation.content.range.sometype.number1"],
    validateContentPropertyRules("sometype", "number1", {"number1": 11}));
assert('Number RANGE bigint fits number',
    [], validateContentPropertyRules("sometype", "number1", {"number1": 10n}));
assert('Date RANGE fits',
    [], validateContentPropertyRules("sometype", "someDate", {"someDate": "2022-01-01T12:00:00Z"}));
assert('Date RANGE min fails',
    ["error.validation.content.range.sometype.someDate"],
    validateContentPropertyRules("sometype", "someDate", {"someDate": "2000-01-01T00:00:00Z"}));
assert('Date RANGE max fails',
    ["error.validation.content.range.sometype.someDate"],
    validateContentPropertyRules("sometype", "someDate", {"someDate": "3000-01-01T00:00:00Z"}));

assert('String SIZE fits',
    [], validateContentPropertyRules("sometype", "someString", {"someString": "right size"}));
assert('String SIZE min fails',
    ["error.validation.content.size.sometype.someString"],
    validateContentPropertyRules("sometype", "someString", {"someString": ""}));
assert('String SIZE max fails',
    ["error.validation.content.size.sometype.someString"],
    validateContentPropertyRules("sometype", "someString", {"someString": "just to long"}));
assert('stringArray SIZE o.k.',
    [], validateContentPropertyRules("sometype", "stringArray", {"stringArray": [1, 2]}));
assert('stringArray SIZE to small',
    ["error.validation.content.size.sometype.stringArray"],
    validateContentPropertyRules("sometype", "stringArray", {"stringArray": [1]}));
assert('stringArray SIZE to big',
    ["error.validation.content.size.sometype.stringArray"],
    validateContentPropertyRules("sometype", "stringArray", {"stringArray": [1, 2, 3, 4]}));
assert('otherDate is SATURDAY',
    [], validateContentPropertyRules("sometype", "otherDate", {"otherDate": "2022-1-1"}));
assert('otherDate is not SATURDAY',
    ["error.validation.content.weekday_any.sometype.otherDate"],
    validateContentPropertyRules("sometype", "otherDate", {"otherDate": "2022-1-2"}));

assert('integerArray[*]#sum equals 6',
    [], validateContentPropertyRules("sometype", "integerArray[*]#sum", {"integerArray": [1, 2, 3]}, ["aaa"]));
assert('integerArray[*]#sum in range(1, 6)',
    [], validateContentPropertyRules("sometype", "integerArray[*]#sum", {"integerArray": [1, 2, 3]}, ["bbb"]));
assert('integerArray[*]#sum not equals 6',
    ["error.validation.content.equals_any.sometype.integerArray[*]#sum"],
    validateContentPropertyRules("sometype", "integerArray[*]#sum", {"integerArray": [1, 2, 4]}, ["aaa"]));
assert('integerArray[*]#sum not in range(1, 6)',
    ["error.validation.content.range.sometype.integerArray[*]#sum"],
    validateContentPropertyRules("sometype", "integerArray[*]#sum", {"integerArray": [1, 2, 4]}, ["bbb"]));

assert('integerArray[*]#distinct equals true',
    [], validateContentPropertyRules("sometype", "integerArray[*]#distinct", {"integerArray": [1, 2, 3]}, ["aaa"]));
assert('integerArray[*]#distinct equals false',
    [], validateContentPropertyRules("sometype", "integerArray[*]#distinct", {"integerArray": [1, 2, 1]}));
assert('stringArray[*]#distinct equals true',
    [], validateContentPropertyRules("sometype", "stringArray[*]#distinct", {"stringArray": ["a", "b", "c"]}, ["aaa"]));
assert('stringArray[*]#distinct equals false',
    [], validateContentPropertyRules("sometype", "stringArray[*]#distinct", {"stringArray": ["a", "b", "a"]}));


log(">>> Testing validateUpdatePropertyRules");
assert('Update someString from "foo" to "bar" is allowed',
    [], validateUpdatePropertyRules("sometype", "someString", {"someString": "foo"}, {"someString": "bar"}));
assert('Update someString from "foo" to "zoo" is allowed for permission "aaa"',
    [], validateUpdatePropertyRules("sometype", "someString", {"someString": "foo"}, {"someString": "zoo"}, ["aaa"]));
assert('Update someString from "foo" to "zoo" is not allowed w/o permission "aaa"',
    ["error.validation.update.equals_any.sometype.someString"],
    validateUpdatePropertyRules("sometype", "someString", {"someString": "foo"}, {"someString": "zoo"}));


log(">>> Testing equalsConstraintIsMet");
assert('String EQUALS_ANY value',
    true, equalsConstraintIsMet({"type": "EQUALS_ANY" , "values": ["foo", "bar", "zoo"]}, "zoo"));
assert('String not EQUALS_ANY value',
    false, equalsConstraintIsMet({"type": "EQUALS_ANY" , "values": ["foo", "bar", "zoo"]}, "baz"));
assert('String EQUALS_NONE value',
    true, equalsConstraintIsMet({"type": "EQUALS_NONE" , "values": ["foo", "bar", "zoo"]}, "baz"));
assert('String not EQUALS_NONE value',
    false, equalsConstraintIsMet({"type": "EQUALS_NONE" , "values": ["foo", "bar", "zoo"]}, "zoo"));
assert('Date EQUALS_ANY value',
    true, equalsConstraintIsMet({"type": "EQUALS_ANY" , "values": ["1999-01-01T00:00:00Z", "2021-01-01T00:00:00Z"]},
        "2021-01-01T00:00:00Z"));
assert('Date not EQUALS_ANY value',
    false, equalsConstraintIsMet({"type": "EQUALS_ANY" , "values": ["1999-01-01T00:00:00Z", "2021-01-01T00:00:00Z"]},
        "3000-01-01T00:00:00Z"));
assert('Date EQUALS_NONE value',
    true, equalsConstraintIsMet({"type": "EQUALS_NONE" , "values": ["1999-01-01T00:00:00Z", "2021-01-01T00:00:00Z"]},
        "3000-01-01T00:00:00Z"));
assert('Date not EQUALS_NONE value',
    false, equalsConstraintIsMet({"type": "EQUALS_NONE" , "values": ["1999-01-01T00:00:00Z", "2021-01-01T00:00:00Z"]},
        "2021-01-01T00:00:00Z"));


log(">>> Testing equalsRefConstraintIsMet");
assert('Value EQUALS_ANY_REF value',
    true, equalsRefConstraintIsMet({"type": "EQUALS_ANY_REF" , "values": ["prop1", "prop2[*]"]}, "zoo",
        {"prop1": "val", "prop2": ["foo", "bar", "zoo"]}));
assert('Value not EQUALS_ANY_REF value',
    false, equalsRefConstraintIsMet({"type": "EQUALS_ANY_REF" , "values": ["prop1", "prop2[*]"]}, "xyz",
        {"prop1": "val", "prop2": ["foo", "bar", "zoo"]}));
assert('Value EQUALS_NONE_REF value',
    true, equalsRefConstraintIsMet({"type": "EQUALS_NONE_REF" , "values": ["prop1", "prop2[*]"]}, "xyz",
        {"prop1": "val", "prop2": ["foo", "bar", "zoo"]}));
assert('Value not EQUALS_NONE_REF value',
    false, equalsRefConstraintIsMet({"type": "EQUALS_NONE_REF" , "values": ["prop1", "prop2[*]"]}, "zoo",
        {"prop1": "val", "prop2": ["foo", "bar", "zoo"]}));
assert('Date EQUALS_ANY_REF date',
    true, equalsRefConstraintIsMet({"type": "EQUALS_ANY_REF" , "values": ["prop1", "prop2[*]"]}, "2022-01-01",
        {"prop1": "1999-01-01", "prop2": ["2000-01-01", "2010-01-01", "2022-01-01"]}));
assert('Number EQUALS_ANY_REF number#sum',
    true, equalsRefConstraintIsMet({"type": "EQUALS_ANY_REF" , "values": ["prop1[*]#sum", "prop2[*]#sum"]}, 15,
        {"prop1": [1, 2, 3], "prop2": [4, 5, 6]}));
assert('Number not EQUALS_ANY_REF number#sum',
    false, equalsRefConstraintIsMet({"type": "EQUALS_ANY_REF" , "values": ["prop1[*]#sum", "prop2[*]#sum"]}, 99,
        {"prop1": [1, 2, 3], "prop2": [4, 5, 6]}));
assert('Boolean EQUALS_ANY_REF number#distinct',
    true, equalsRefConstraintIsMet({"type": "EQUALS_ANY_REF" , "values": ["prop1[*]#distinct"]}, true,
        {"prop1": [1, 2, 3]}));
assert('Boolean not EQUALS_ANY_REF number#distinct',
    false, equalsRefConstraintIsMet({"type": "EQUALS_ANY_REF" , "values": ["prop1[*]#distinct"]}, true,
        {"prop1": [1, 2, 2]}));


log(">>> Testing regexConstraintIsMet");
assert('String REGEX_ANY match',
    true, regexConstraintIsMet({"type": "REGEX_ANY", "values": ["nomatch", "^[fz]o{2}$"]}, "zoo"));
assert('String not REGEX_ANY match',
    false, regexConstraintIsMet({"type": "REGEX_ANY", "values": ["nomatch"]}, "zoo"));
assert('Number REGEX_ANY match',
    true, regexConstraintIsMet({"type": "REGEX_ANY", "values": ["nomatch", "^[0-7]+$"]}, 1234567));
assert('Number not REGEX_ANY match',
    false, regexConstraintIsMet({"type": "REGEX_ANY", "values": ["nomatch"]}, 1234567));


log(">>> Testing sizeConstraintIsMet");
assert('Property is null',
    false, sizeConstraintIsMet({"type": "SIZE", "min": 1}, null));
assert('Type property invalid',
    false, sizeConstraintIsMet({"typ_": "SIZE"}, "Test"));
assert('Type value is invalid',
    false, sizeConstraintIsMet({"type": "SIZE_"}, "Test"));
assert('Properties "min" and "max" are missing',
    false, sizeConstraintIsMet({"type": "SIZE"}, "Test"));
assert('Properties "min" is not typeof "number"',
    false, sizeConstraintIsMet({"type": "SIZE", "min": 'x'}, 123));
assert('Properties "max" is not typeof "number"',
    false, sizeConstraintIsMet({"type": "SIZE", "max": '-1'}, 123));
assert('Number is not allowed',
    false, sizeConstraintIsMet({"type": "SIZE", "min": 1}, 123));
assert('String should have min size',
    true, sizeConstraintIsMet({"type": "SIZE", "min": 1}, "T"));
assert('String should have max size',
    true, sizeConstraintIsMet({"type": "SIZE", "max": 10}, "Teststring"));
assert('String should have min and max size',
    true, sizeConstraintIsMet({"type": "SIZE","min": 1, "max": 10}, "Teststring"));
assert('String is to short',
    false, sizeConstraintIsMet({"type": "SIZE", "min": 11}, "Teststring"));
assert('String is too long',
    false, sizeConstraintIsMet({"type": "SIZE", "max": 9}, "Teststring"));
assert('Array should have min size',
    true, sizeConstraintIsMet({"type": "SIZE", "min": 1}, [1]));
assert('Array should have max size',
    true, sizeConstraintIsMet({"type": "SIZE", "max": 3}, [1 ,2, 3]));
assert('Array is to short',
    false, sizeConstraintIsMet({"type": "SIZE", "min": 2}, [1]));
assert('Array is to long',
    false, sizeConstraintIsMet({"type": "SIZE", "max": 2}, [1 ,2, 3]));
assert('Object should have min size',
    true, sizeConstraintIsMet({"type": "SIZE", "min": 1}, {"one": 1, "two": 2}));
assert('Object should have max size',
    true, sizeConstraintIsMet({"type": "SIZE", "max": 2}, {"one": 1, "two": 2}));
assert('Object is to short',
    false, sizeConstraintIsMet({"type": "SIZE", "min": 3}, {"one": 1, "two": 2}));


log(">>> Testing rangeConstraintIsMet");
assert('False if property is null',
    false, rangeConstraintIsMet({"type": "RANGE", "min": 1}, null));
assert('False if property is undefined',
    false, rangeConstraintIsMet({"type": "RANGE", "min": 1}, undefined));
assert('Type property invalid',
    false, rangeConstraintIsMet({"typ_": "RANGE"}, 1));
assert('Type value is invalid',
    false, rangeConstraintIsMet({"type": "RANGE_"}, 1));
assert('Properties "min" and "max" are missing',
    false, rangeConstraintIsMet({"type": "RANGE"}, 1));
assert('Properties "min" is not typeof "number"',
    false, rangeConstraintIsMet({"type": "RANGE", "min": 'x'}, 123));
assert('Properties "max" is not typeof "number"',
    false, rangeConstraintIsMet({"type": "RANGE", "max": '-1'}, 123));
assert('String is not allowed',
    false, rangeConstraintIsMet({"type": "RANGE", "min": 1}, "String"));
assert('Date is not allowed',
    false, rangeConstraintIsMet({"type": "RANGE", "min": 1}, new Date()));
assert('Array is not allowed',
    false, rangeConstraintIsMet({"type": "RANGE", "min": 1}, [1, 2]));
assert('Object is not allowed',
    false, rangeConstraintIsMet({"type": "RANGE", "min": 1}, {"one": 1, "two": 2}));
assert('Number should be <= min',
    true, rangeConstraintIsMet({"type": "RANGE", "min": 1}, 1));
assert('Number should be >= max',
    true, rangeConstraintIsMet({"type": "RANGE", "max": 2}, 2));
assert('Number is < min',
    false, rangeConstraintIsMet({"type": "RANGE", "min": 2}, 1));
assert('Number is > max',
    false, rangeConstraintIsMet({"type": "RANGE", "max": 1}, 2));


log(">>> Testing dateConstraintIsMet");
const currentYear = new Date().getFullYear();
const currentMonth = new Date().getMonth();
const currentDate = new Date().getDate();

assert('False if property is null',
    false, dateConstraintIsMet({"type": "FUTURE_DAYS", "min": 0}, null));
assert('False if property is undefined',
    false, dateConstraintIsMet({"type": "FUTURE_DAYS", "min": 0}, undefined));
assert('Property "min" and "max" are missing',
    false, dateConstraintIsMet({"type": "FUTURE_DAYS"}, "3000-01-31"));

assert('FUTURE min 0 against now',
    true, dateConstraintIsMet({"type": "FUTURE_DAYS", "min": 0}, new Date().toISOString()));
assert('FUTURE min/max 0 against now',
    true, dateConstraintIsMet({"type": "FUTURE_DAYS", "min": 0, "max": 0}, new Date().toISOString()));
assert('FUTURE min 1 against today',
    false, dateConstraintIsMet({"type": "FUTURE_DAYS", "min": 1}, new Date().toISOString()));
assert('FUTURE min 1 against year 3000',
    true, dateConstraintIsMet({"type": "FUTURE_DAYS", "min": 1}, "3000-01-31"));
assert('FUTURE min 1 max 365000 against year 3000',
    true, dateConstraintIsMet({"type": "FUTURE_DAYS", "min": 1, "max": 365000}, "3000-01-31"));
assert('FUTURE min 1 max 1000 against year 3000',
    false, dateConstraintIsMet({"type": "FUTURE_DAYS", "min": 1, "max": 1000}, "3000-01-31"));

assert('PAST min 0 against now',
    true, dateConstraintIsMet({"type": "PAST_DAYS", "min": 0}, new Date().toISOString()));
assert('PAST min/max 0 against now',
    true, dateConstraintIsMet({"type": "PAST_DAYS", "min": 0, "max": 0}, new Date().toISOString()));
assert('PAST min 1 against today',
    false, dateConstraintIsMet({"type": "PAST_DAYS", "min": 1}, new Date().toISOString()));
assert('PAST min 1 against year 2000',
    true, dateConstraintIsMet({"type": "PAST_DAYS", "min": 1}, "2020-01-01"));
assert('PAST min 10000 against year 2020',
    false, dateConstraintIsMet({"type": "PAST_DAYS", "min": 10000}, "2020-01-01"));
assert('PAST min 1 max 10000 against year 2020',
    true, dateConstraintIsMet({"type": "PAST_DAYS", "min": 1, "max": 10000}, "2020-01-01"));
assert('PAST min 1 max 1000 against year 2000',
    false, dateConstraintIsMet({"type": "PAST_DAYS", "min": 1, "max": 1000}, "2000-01-01"));

assert('PERIOD min 0 against now',
    true, dateConstraintIsMet({"type": "PERIOD_DAYS", "min": 0}, new Date().toISOString()));
assert('PERIOD max 0 against now',
    true, dateConstraintIsMet({"type": "PERIOD_DAYS", "max": 0}, new Date().toISOString()));
assert('PERIOD min -365 max 365 against now - 365 days',
    true, dateConstraintIsMet({"type": "PAST_DAYS", "min": -365, "max": 365},
        new Date(currentYear-1, currentMonth, currentDate).toISOString()));
assert('PERIOD min -365 max 365 against now + 365 days',
    true, dateConstraintIsMet({"type": "PAST_DAYS", "min": -365, "max": 365},
        new Date(currentYear+1, currentMonth, currentDate).toISOString()));
assert('PERIOD min -365 max 365 against now - 2 years',
    false, dateConstraintIsMet({"type": "PAST_DAYS", "min": -365, "max": 365},
        new Date(currentYear-2, currentMonth, currentDate).toISOString()));
assert('PERIOD min -365 max 365 against now + 2 years',
    false, dateConstraintIsMet({"type": "PAST_DAYS", "min": -365, "max": 365},
        new Date(currentYear+2, currentMonth, currentDate).toISOString()));


log(">>> Testing weekdayConstraintIsMet");
assert('False if WEEKDAY_ANY days is missing',
    false, weekdayConstraintIsMet({"type": "WEEKDAY_ANY"}, '2022-01-01'));
assert('False if WEEKDAY_ANY days is not an array',
    false, weekdayConstraintIsMet({"type": "WEEKDAY_ANY", "days": {}}, '2022-01-01'));
assert('False if WEEKDAY_ANY days is empty',
    false, weekdayConstraintIsMet({"type": "WEEKDAY_ANY", "days": []}, '2022-01-01'));
assert('False if WEEKDAY_ANY days do not match',
    false, weekdayConstraintIsMet({"type": "WEEKDAY_ANY", "days": ["MONDAY"]}, '2022-01-01'));
assert('False if WEEKDAY_ANY days do not contain "null"',
    false, weekdayConstraintIsMet({"type": "WEEKDAY_ANY", "days": ["MONDAY"]}, null));
assert('True if WEEKDAY_ANY days contain "null"',
    true, weekdayConstraintIsMet({"type": "WEEKDAY_ANY", "days": ["MONDAY", "null"]}, null));
assert('True if WEEKDAY_ANY days do match',
    true, weekdayConstraintIsMet({"type": "WEEKDAY_ANY", "days": ["SATURDAY"]}, '2022-01-01'));


log(">>> Testing inflatePropertyIfMultiIndexed");
assert('*.index is inflated correct',
    ["a[0]","a[1]","a[2]","a[3]","a[4]"], inflatePropertyIfMultiIndexed("a[*]", {a:[0,0,0,0,0]}));
assert('start/step-index is inflated correct',
    ["a[1]","a[3]"], inflatePropertyIfMultiIndexed("a[1/2]", {a:[0,0,0,0,0]}));
assert('range-index is inflated correct',
    ["a[1]","a[2]","a[3]"], inflatePropertyIfMultiIndexed("a[1-3]", {a:[0,0,0,0,0]}));
assert('list-index is inflated correct',
    ["a[1]","a[4]"], inflatePropertyIfMultiIndexed("a[1,4]", {a:[0,0,0,0,0]}));
assert('combined-index is inflated correct',
    ["a[0].b[0].c[2].d","a[1].b[0].c[2].d","a[1].b[1].c[2].d"],
    inflatePropertyIfMultiIndexed("a[*].b[0/1].c[2].d", {a:[{b:[0]},{b:[0,0]}]}));


log(">>> Testing set/getDefault*MessagePrefix");
setDefaultMandatoryMessagePrefix("foo");
assert('setDefaultMandatoryMessagePrefix o.k.',
    "foo", getDefaultMandatoryMessagePrefix("foo"));
setDefaultImmutableMessagePrefix(("zoo"));
assert('setDefaultImmutableMessagePrefix o.k.',
    "zoo", getDefaultImmutableMessagePrefix("zoo"));
setDefaultContentMessagePrefix("bar");
assert('setDefaultContentMessagePrefix o.k.',
    "bar", getDefaultContentMessagePrefix("bar"));
setDefaultUpdateMessagePrefix("baz");
assert('setDefaultUpdateMessagePrefix o.k.',
    "baz", getDefaultUpdateMessagePrefix("baz"));


log("END OF TESTS");
logResult();
</script>
</body>
</html>
