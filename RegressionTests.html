<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>RegressionTests</title>
    <style>
        p {font-family: sans-serif;}
        .ok {color: green;}
        .err {color: tomato;}
        .info {color: darkblue;}
    </style>
</head>
<body>
<div id="console"></div>
<script type="module">
import {setValidationRules, isPropertyMandatory, validateMandatoryPropertyRules, isPropertyImmutable,
    validateImmutablePropertyRules, validateContentPropertyRules, validateUpdatePropertyRules}
    from './CrossLanguageValidation_ES6.js';
import {sizeConstraintIsMet, rangeConstraintIsMet, dateConstraintIsMet, equalsConstraintIsMet, equalsRefConstraintIsMet,
    regexConstraintIsMet, inflatePropertyIfMultiIndexed} from './CrossLanguageValidation_ES6.js';
import {testValidationRules, sometype} from './RegressionTestsData_ES6.js';

var console = document.getElementById("console");
function log(text, cssClass = "info") {
    var para = document.createElement("P");
    para.setAttribute("class", cssClass)
    para.appendChild(document.createTextNode(text));
    console.appendChild(para);
}
function assert(msg, expected, compare) {
    if (Array.isArray(expected) && Array.isArray(compare)) {
        expected = expected.toString();
        compare = compare.toString();
    }
    if (expected !== compare) {
        log("Assertion failure: " +  msg + ". Expected " + expected + ", but got " + compare, "err");
    } else {
        log("Test o.k.: " +  msg, "ok");
    }
}
setValidationRules(testValidationRules);

log(">>> Testing validateUpdatePropertyRules")
assert('Update someString from "foo" to "bar" is allowed',
    "VALID", validateUpdatePropertyRules("sometype", "someString", {"someString": "foo"}, {"someString": "bar"}));
assert('Update someString from "foo" to "zoo" is allowed for permission "aaa"',
    "VALID", validateUpdatePropertyRules("sometype", "someString", {"someString": "foo"}, {"someString": "zoo"}, ["aaa"]));
assert('Update someString from "foo" to "zoo" is not allowed w/o permission "aaa"',
    "error.validation.content.sometype.someString",
    validateUpdatePropertyRules("sometype", "someString", {"someString": "foo"}, {"someString": "zoo"}));

log(">>> Testing validateContentPropertyRules")
assert('Number RANGE fits',
    "VALID", validateContentPropertyRules("sometype", "number1", {"number1": 3}));
assert('Number RANGE min fails',
    "error.validation.content.sometype.number1",
    validateContentPropertyRules("sometype", "number1", {"number1": 0}));
assert('Number RANGE max fails',
    "error.validation.content.sometype.number1",
    validateContentPropertyRules("sometype", "number1", {"number1": 11}));
assert('String SIZE fits',
    "VALID", validateContentPropertyRules("sometype", "someString", {"someString": "right size"}));
assert('String SIZE min fails',
    "error.validation.content.sometype.someString",
    validateContentPropertyRules("sometype", "someString", {"someString": ""}));
assert('String SIZE max fails',
    "error.validation.content.sometype.someString",
    validateContentPropertyRules("sometype", "someString", {"someString": "just to long"}));

log(">>> Testing isPropertyMandatory")
assert('non-existing property is not mandatory',
    false, isPropertyMandatory("sometype", "non-existing", sometype));
assert('customer (with no conditions) is mandatory ',
    true, isPropertyMandatory("sometype", "customer", sometype));
assert('id is mandatory for permission "aaa"',
    true, isPropertyMandatory("sometype", "id", sometype, ["aaa", "xxx"]));
assert('id is mandatory for permission "bbb"',
    true, isPropertyMandatory("sometype", "id", sometype, ["xxx", "bbb"]));
assert('id is mandatory for permission "ccc"',
    true, isPropertyMandatory("sometype", "id", sometype, ["ccc"]));
assert('id is mandatory for no (matching) permission',
    true, isPropertyMandatory("sometype", "id", sometype, ["xxx"]));
assert('array with *-index is mandatory',
    true, isPropertyMandatory("sometype", "stringArray[*]", sometype));

log(">>> Testing isPropertyImmutable")
assert('id is immutable for no (matching) permission',
    true, isPropertyImmutable("sometype", "id", sometype));

log(">>> Testing validateMandatoryPropertyRules")
assert('id is mandatory and not null',
    "VALID", validateMandatoryPropertyRules("sometype", "id", {"id": 1}));
assert('id is mandatory but null',
    "error.validation.mandatory.sometype.id", validateMandatoryPropertyRules("sometype", "id", {"id": null}));
assert('stringArray[*] elements are not null',
    "VALID", validateMandatoryPropertyRules("sometype", "stringArray[*]", sometype));

log(">>> Testing validateImmutablePropertyRules")
assert('id is immutable and unchanged',
    "VALID", validateImmutablePropertyRules("sometype", "id", {"id": 1}, {"id": 1}));
assert('id is immutable but changed',
    "error.validation.immutable.sometype.id",
    validateImmutablePropertyRules("sometype", "id", {"id": 1}, {"id": 2}));

log(">>> Testing equalsConstraintIsMet")
assert('String EQUALS_ANY value',
    true, equalsConstraintIsMet({"type": "EQUALS_ANY" , "values": ["foo", "bar", "zoo"]}, "zoo"));
assert('String not EQUALS_ANY value',
    false, equalsConstraintIsMet({"type": "EQUALS_ANY" , "values": ["foo", "bar", "zoo"]}, "baz"));
assert('String EQUALS_NONE value',
    true, equalsConstraintIsMet({"type": "EQUALS_NONE" , "values": ["foo", "bar", "zoo"]}, "baz"));
assert('String not EQUALS_NONE value',
    false, equalsConstraintIsMet({"type": "EQUALS_NONE" , "values": ["foo", "bar", "zoo"]}, "zoo"));
assert('Date EQUALS_ANY value',
    true, equalsConstraintIsMet({"type": "EQUALS_ANY" , "values": ["1999-01-01T00:00:00Z", "2021-01-01T00:00:00Z"]},
        "2021-01-01T00:00:00Z"));
assert('Date not EQUALS_ANY value',
    false, equalsConstraintIsMet({"type": "EQUALS_ANY" , "values": ["1999-01-01T00:00:00Z", "2021-01-01T00:00:00Z"]},
        "3000-01-01T00:00:00Z"));
assert('Date EQUALS_NONE value',
    true, equalsConstraintIsMet({"type": "EQUALS_NONE" , "values": ["1999-01-01T00:00:00Z", "2021-01-01T00:00:00Z"]},
        "3000-01-01T00:00:00Z"));
assert('Date not EQUALS_NONE value',
    false, equalsConstraintIsMet({"type": "EQUALS_NONE" , "values": ["1999-01-01T00:00:00Z", "2021-01-01T00:00:00Z"]},
        "2021-01-01T00:00:00Z"));

log(">>> Testing equalsRefConstraintIsMet")
assert('Value EQUALS_ANY_REF value',
    true, equalsRefConstraintIsMet({"type": "EQUALS_ANY_REF" , "values": ["prop1", "prop2[*]"]}, "zoo",
        {"prop1": "val", "prop2": ["foo", "bar", "zoo"]}));
assert('Value do not EQUALS_ANY_REF valued',
    false, equalsRefConstraintIsMet({"type": "EQUALS_ANY_REF" , "values": ["prop1", "prop2[*]"]}, "xyz",
        {"prop1": "val", "prop2": ["foo", "bar", "zoo"]}));
assert('Value EQUALS_NONE_REF value',
    true, equalsRefConstraintIsMet({"type": "EQUALS_NONE_REF" , "values": ["prop1", "prop2[*]"]}, "xyz",
        {"prop1": "val", "prop2": ["foo", "bar", "zoo"]}));
assert('Value do notEQUALS_NONE_REF value',
    false, equalsRefConstraintIsMet({"type": "EQUALS_NONE_REF" , "values": ["prop1", "prop2[*]"]}, "zoo",
        {"prop1": "val", "prop2": ["foo", "bar", "zoo"]}));

log(">>> Testing regexConstraintIsMet")
assert('String REGEX_ANY match',
    true, regexConstraintIsMet({"type": "REGEX_ANY", "values": ["nomatch", "^[fz]o{2}$"]}, "zoo"));
assert('Number REGEX_ANY match',
    true, regexConstraintIsMet({"type": "REGEX_ANY", "values": ["nomatch", "^[0-7]+$"]}, 1234567));

log(">>> Testing sizeConstraintIsMet")
assert('Type property invalid',
    false, sizeConstraintIsMet({"typ_": "SIZE"}, "Test"));
assert('Type value is invalid',
    false, sizeConstraintIsMet({"type": "SIZE_"}, "Test"));
assert('Properties "min" and "max" are missing',
    false, sizeConstraintIsMet({"type": "SIZE"}, "Test"));
assert('Properties "min" is not typeof "number"',
    false, sizeConstraintIsMet({"type": "SIZE", "min": 'x'}, 123));
assert('Properties "max" is not typeof "number"',
    false, sizeConstraintIsMet({"type": "SIZE", "max": '-1'}, 123));
assert('Number is not allowed',
    false, sizeConstraintIsMet({"type": "SIZE", "min": 1}, 123));
assert('String should have min size',
    true, sizeConstraintIsMet({"type": "SIZE", "min": 1}, "T"));
assert('String should have max size',
    true, sizeConstraintIsMet({"type": "SIZE", "max": 10}, "Teststring"));
assert('String should have min and max size',
    true, sizeConstraintIsMet({"type": "SIZE","min": 1, "max": 10}, "Teststring"));
assert('String is to short',
    false, sizeConstraintIsMet({"type": "SIZE", "min": 11}, "Teststring"));
assert('String is too long',
    false, sizeConstraintIsMet({"type": "SIZE", "max": 9}, "Teststring"));
assert('Array should have min size',
    true, sizeConstraintIsMet({"type": "SIZE", "min": 1}, [1]));
assert('Array should have max size',
    true, sizeConstraintIsMet({"type": "SIZE", "max": 3}, [1 ,2, 3]));
assert('Array is to short',
    false, sizeConstraintIsMet({"type": "SIZE", "min": 2}, [1]));
assert('Array is to long',
    false, sizeConstraintIsMet({"type": "SIZE", "max": 2}, [1 ,2, 3]));
assert('Object should have min size',
    true, sizeConstraintIsMet({"type": "SIZE", "min": 1}, {"one": 1, "two": 2}));
assert('Object should have max size',
    true, sizeConstraintIsMet({"type": "SIZE", "max": 2}, {"one": 1, "two": 2}));
assert('Object is to short',
    false, sizeConstraintIsMet({"type": "SIZE", "min": 3}, {"one": 1, "two": 2}));
assert('Object is to long',
    false, sizeConstraintIsMet({"type": "SIZE", "max": 1}, {"one": 1, "two": 2}));

log(">>> Testing rangeConstraintIsMet")
assert('Type property invalid',
    false, rangeConstraintIsMet({"typ_": "RANGE"}, 1));
assert('Type value is invalid',
    false, rangeConstraintIsMet({"type": "RANGE_"}, 1));
assert('Properties "min" and "max" are missing',
    false, rangeConstraintIsMet({"type": "RANGE"}, 1));
assert('Properties "min" is not typeof "number"',
    false, rangeConstraintIsMet({"type": "RANGE", "min": 'x'}, 123));
assert('Properties "max" is not typeof "number"',
    false, rangeConstraintIsMet({"type": "RANGE", "max": '-1'}, 123));
assert('String is not allowed',
    false, rangeConstraintIsMet({"type": "RANGE", "min": 1}, "String"));
assert('Date is not allowed',
    false, rangeConstraintIsMet({"type": "RANGE", "min": 1}, new Date()));
assert('Array is not allowed',
    false, rangeConstraintIsMet({"type": "RANGE", "min": 1}, [1, 2]));
assert('Object is not allowed',
    false, rangeConstraintIsMet({"type": "RANGE", "min": 1}, {"one": 1, "two": 2}));
assert('Number should be <= min',
    true, rangeConstraintIsMet({"type": "RANGE", "min": 1}, 1));
assert('Number should be >= max',
    true, rangeConstraintIsMet({"type": "RANGE", "max": 2}, 2));
assert('Number is < min',
    false, rangeConstraintIsMet({"type": "RANGE", "min": 2}, 1));
assert('Number is > max',
    false, rangeConstraintIsMet({"type": "RANGE", "max": 1}, 2));

log(">>> Testing dateConstraintIsMet")
assert('Property "days" is missing',
    false, dateConstraintIsMet({"type": "DATE_FUTURE"}, new Date()));
assert('FUTURE 0 against now',
    false, dateConstraintIsMet({"type": "DATE_FUTURE", "days": 0}, new Date()));
assert('PAST 0 against now',
    false, dateConstraintIsMet({"type": "DATE_PAST", "days": 0}, new Date()));
assert('FUTURE 1 against now',
    false, dateConstraintIsMet({"type": "DATE_FUTURE", "days": 1}, new Date()));
assert('PAST 1 against now',
    false, dateConstraintIsMet({"type": "DATE_PAST", "days": 1}, new Date()));
assert('FUTURE 1 against year 3000',
    true, dateConstraintIsMet({"type": "DATE_FUTURE", "days": 1}, new Date("3000-01-31")));
assert('PAST 1 against year 2020',
    true, dateConstraintIsMet({"type": "DATE_PAST", "days": 1}, new Date("2020-01-01")));
assert('PAST 10000 against year 2020',
    false, dateConstraintIsMet({"type": "DATE_PAST", "days": 1000}, new Date("2020-01-01")));

log(">>> Testing inflatePropertyIfMultiIndexed")
assert('*.index is inflated correct',
    ["a[0]","a[1]","a[2]","a[3]","a[4]"], inflatePropertyIfMultiIndexed("a[*]", {a:[0,0,0,0,0]}));
assert('start/step-index is inflated correct',
    ["a[1]","a[3]"], inflatePropertyIfMultiIndexed("a[1/2]", {a:[0,0,0,0,0]}));
assert('range-index is inflated correct',
    ["a[1]","a[2]","a[3]"], inflatePropertyIfMultiIndexed("a[1-3]", {a:[0,0,0,0,0]}));
assert('list-index is inflated correct',
    ["a[1]","a[4]"], inflatePropertyIfMultiIndexed("a[1,4]", {a:[0,0,0,0,0]}));
assert('combined-index is inflated correct',
    ["a[0].b[0].c[2].d","a[1].b[0].c[2].d","a[1].b[1].c[2].d"],
    inflatePropertyIfMultiIndexed("a[*].b[0/1].c[2].d", {a:[{b:[0]},{b:[0,0]}]}));

</script>
</body>
</html>
